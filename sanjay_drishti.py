# -*- coding: utf-8 -*-
"""Sanjay_Drishti.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dd0_7tTC-gPdTgtPCDgH7xAIcxcnEQSd
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import cv2
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

ch_out = []
character = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']

model=load_model('character_classification.h5')

def sortcnts(cnts):                 
	boundingBoxes = [cv2.boundingRect(c) for c in cnts]  #list of x,y,w,h for all the contours
	(cnts, boundingBoxes) = zip(*sorted(zip(cnts, boundingBoxes),key=lambda b:b[1][0], reverse=False)) # to sort the contours left to right along x-axis
	return (cnts)

def test(a,b,c,d,imd): # To predict the character present in the region of interest.
    test=imd[b:b+d,a:a+c]
    _,test_image = cv2.threshold(test,100,255,cv2.THRESH_BINARY)
    test_image = cv2.copyMakeBorder(test_image,10,10,10,10,cv2.BORDER_CONSTANT,value=(255,255,255)) #making border of the test image.
    test_image = cv2.bilateralFilter(test_image,9,75,75) #bilateral filter helps to process the edges in an image while removing the noise.
    test_image = cv2.resize(test_image,(28,28),interpolation = cv2.INTER_AREA)
    test_image = (image.img_to_array(test_image))/255 #representing image as an array and then normalising the dataset btw 0-1.
    test_image = np.expand_dims(test_image, axis = 0) #making list/1D array of 28x28 no., to pass through the model.
    result = model.predict(test_image)  
    np.reshape(result, 62) #reshape the numpy array from (1,62) to 1-D array of (62,)
    high = np.amax(test_image)
    low = np.amin(test_image)
    if high != low:
        maxval = np.amax(result)
        index = np.where(result == maxval)
        ch_out.append(character[index[1][0]])

def predict(input_img):    
    img = cv2.cvtColor(input_img, cv2.COLOR_BGR2GRAY)
    
    # Code for enhancing the image--------------------------------------------------
    
    blur = cv2.bilateralFilter(img,9,75,75)
    _, thresh = cv2.threshold(blur, 100, 255, cv2.THRESH_BINARY) 

    contours, hierachy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) #cv2.RETR_TREE gives contours in hierachy

    sum_width = 0
    for cnt in contours:
        x,y,w,h = cv2.boundingRect(cnt)
        sum_width += w
    avg_width = sum_width/len(contours)
    
    y_prev=0
    maxar = 10000 
    minar = 1000
    for cnt in contours:
        #x,y coordinates of bottom left corner, w and h for width and height
        x,y,w,h = cv2.boundingRect(cnt)
        if w*h < maxar and w*h > minar:
          if (y-y_prev)>2*avg_width:
            ch_out.append(" ")
          test(x,y,w,h,img)
          y_prev=y

    final = ""
    i = 0
    for ch in reversed(ch_out):
      i += 1
      final = final+ch

    print(final)